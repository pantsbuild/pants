# Copyright 2024 Pants project contributors (see CONTRIBUTORS.md).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

import importlib.util
import json
import logging
from dataclasses import dataclass
from functools import partial
from pathlib import Path, PurePath
from typing import Callable, TypedDict, Union

import libcst as cst
import libcst.matchers as m
from libcst.display import dump

from pants.base.build_environment import get_buildroot
from pants.base.exiter import PANTS_SUCCEEDED_EXIT_CODE, ExitCode
from pants.base.specs import Specs
from pants.build_graph.build_configuration import BuildConfiguration
from pants.engine.fs import Paths
from pants.engine.unions import UnionMembership
from pants.goal.builtin_goal import BuiltinGoal
from pants.init.engine_initializer import GraphSession
from pants.option.option_types import BoolOption
from pants.option.options import Options
from pants.util.strutil import softwrap

logger = logging.getLogger(__name__)


class MigrateCallByNameBuiltinGoal(BuiltinGoal):
    name = "migrate-call-by-name"
    help = softwrap(
        """
        Migrate from `Get` syntax to call-by-name syntax (#19730). This is a **destructive** operation,
        so only run this on source controlled files that you are prepared to revert if necessary.

        This goal will attempt to migrate the set of paths/targets specified at the command line
        if they are part of the "migration plan". This migration does not add any new files, but
        instead modifies existing files in-place without any formatting. The resulting changes should
        be reviewed, tested, and formatted/linted before committing.

        The migration plan is a JSON representation of the rule graph, which is generated by the
        engine based on the active backends/rules in the project.

        Each item in the migration plan is a rule that contains the old `Get` syntax, the associated
        input/output types, and the new function to directly call. The migration plan can be dumped as
        JSON using the `--json` flag, which can be useful for debugging. For example:

        {
            "filepath": "src/python/pants/source/source_root.py",
            "function": "get_source_roots",
            "gets": [{
                "input_types": [{ "module": "pants.source.source_root", "name": "SourceRootsRequest" }],
                "output_type": { "module": "pants.source.source_root", "name": "OptionalSourceRootsResult" },
                "rule_dep": { "function": "get_optional_source_roots", "module": "pants.source.source_root" }
            }],
            "module": "pants.source.source_root"
        }
        """
    )

    should_dump_json = BoolOption(
        flag_name="--json", help=softwrap("Dump the migration plan as JSON"), default=False
    )

    def run(
        self,
        *,
        build_config: BuildConfiguration,
        graph_session: GraphSession,
        options: Options,
        specs: Specs,
        union_membership: UnionMembership,
    ) -> ExitCode:
        migration_plan = self._create_migration_plan(graph_session, PurePath(get_buildroot()))
        if self.should_dump_json:
            print(json.dumps(migration_plan, indent=2, sort_keys=True))

        path_globs = specs.includes.to_specs_paths_path_globs()
        if not path_globs.globs:
            return PANTS_SUCCEEDED_EXIT_CODE

        plan_files = {item["filepath"] for item in migration_plan}

        paths: list[Paths] = graph_session.scheduler_session.product_request(Paths, [path_globs])
        requested_files = set(paths[0].files)

        files_to_migrate = requested_files.intersection(plan_files)
        if not files_to_migrate:
            logger.info(
                f"None of the {len(requested_files)} requested files are part of the {len(plan_files)} files in the migration plan"
            )
            return PANTS_SUCCEEDED_EXIT_CODE

        syntax_mapper = CallByNameSyntaxMapper(migration_plan)
        for f in sorted(files_to_migrate):
            file = Path(f)
            logger.error(f"Processing {file}")

            transformer = CallByNameTransformer(file, syntax_mapper)
            with open(file) as f:
                logging.info(f"Processing {file}")
                source_code = f.read()
                tree = cst.parse_module(source_code)
                new_tree = tree.visit(transformer)
                new_source = new_tree.code
                # logger.error(f"New source is {new_source}")
                if source_code != new_source:
                    logger.error(f"Rewriting {file}")
                    with open(file, "w") as f:
                        f.write(new_source)

        return PANTS_SUCCEEDED_EXIT_CODE

    def _create_migration_plan(
        self, session: GraphSession, build_root: PurePath
    ) -> list[RuleGraphGet]:
        """Use the rule graph to create a migration plan for each "active" file that uses the old
        Get() syntax.

        This function is mostly about creating a stable-sorted collection of items with metadata for
        downstream
        """
        items: list[RuleGraphGet] = []
        for rule, deps in session.scheduler_session.rule_graph_rule_gets().items():
            if isinstance(rule, partial):
                # Ignoring partials, see https://github.com/pantsbuild/pants/issues/20744
                continue

            assert (spec := importlib.util.find_spec(rule.__module__)) is not None
            assert spec.origin is not None
            spec_origin = PurePath(spec.origin)

            item: RuleGraphGet = {
                "filepath": str(spec_origin.relative_to(build_root)),
                "module": rule.__module__,
                "function": rule.__name__,
                "gets": [],
            }
            unsorted_deps: list[RuleGraphGetDep] = []

            for output_type, input_types, rule_dep in deps:
                if isinstance(rule_dep, partial):
                    # Ignoring partials, see https://github.com/pantsbuild/pants/issues/20744
                    continue

                unsorted_deps.append(
                    {
                        "input_types": sorted(
                            [
                                {
                                    "module": input_type.__module__,
                                    "name": input_type.__name__,
                                }
                                for input_type in input_types
                            ],
                            key=lambda x: (x["module"], x["name"]),
                        ),
                        "output_type": {
                            "module": output_type.__module__,
                            "name": output_type.__name__,
                        },
                        "rule_dep": {
                            "function": rule_dep.__name__,
                            "module": rule_dep.__module__,
                        },
                    }
                )

            sorted_deps = sorted(
                unsorted_deps, key=lambda x: (x["rule_dep"]["module"], x["rule_dep"]["function"])
            )
            item["gets"] = sorted_deps
            items.append(item)

        return sorted(items, key=lambda x: (x["filepath"], x["function"]))


# ------------------------------------------------------------------------------------------
# Migration Plan Typed Dicts
# ------------------------------------------------------------------------------------------


class RuleGraphGet(TypedDict):
    filepath: str
    function: str
    module: str
    gets: list[RuleGraphGetDep]


class RuleGraphGetDep(TypedDict):
    input_types: list[RuleType]
    output_type: RuleType
    rule_dep: RuleFunction


class RuleType(TypedDict):
    module: str
    name: str


class RuleFunction(TypedDict):
    function: str
    module: str


# ------------------------------------------------------------------------------------------
# Replacement container
# ------------------------------------------------------------------------------------------


@dataclass
class Replacement:
    filename: PurePath
    module: str
    current_source: cst.Call
    new_source: cst.Call
    additional_imports: list[cst.ImportFrom]

    def sanitized_imports(self) -> list[cst.ImportFrom]:
        """Remove any circular or self-imports."""
        cst_module = _make_importfrom_attr(self.module)
        return [i for i in self.additional_imports if i.module != cst_module]

    # def sanitize(self, names: set[str]):
    #     """Remove any shadowing of names, except if the new_func is in the current file."""
    #     assert isinstance(self.new_source.func, cst.Name)
    #     func_name = self.new_source.func.id
    #     if func_name not in names:
    #         return

    #     # If the new function is not in the sanitized imports, it must be in the current file
    #     if not any(i.names[0].name == func_name for i in self.sanitized_imports()):
    #         return

    #     bound_name = f"{func_name}_get"
    #     self.new_source.func.id = bound_name
    #     for i in self.additional_imports:
    #         if i.names[0].name == func_name:
    #             i.names[0].asname = bound_name
    #     logging.warning(f"Renamed {func_name} to {bound_name} to avoid shadowing")

    def __str__(self) -> str:
        return f"""
        Replacement(
            filename={self.filename},
            module={self.module},
            current_source={dump(self.current_source)},
            new_source={dump(self.new_source)},
            additional_imports={[dump(i) for i in self.additional_imports]},
        )
        """


# ------------------------------------------------------------------------------------------
# Call-by-name syntax mapping
# ------------------------------------------------------------------------------------------


class CallByNameSyntaxMapper:
    def __init__(self, graphs: list[RuleGraphGet]) -> None:
        self.graphs = graphs

        self.mapping: dict[
            tuple[int, type[cst.Call] | type[cst.Dict] | None],
            Callable[[cst.Call, list[RuleGraphGetDep]], tuple[cst.Call, list[cst.ImportFrom]]],
        ] = {
            (1, None): self.map_no_args_get_to_new_syntax,
            (2, cst.Call): self.map_short_form_get_to_new_syntax,
            (2, cst.Dict): self.map_dict_form_get_to_new_syntax,
            (3, None): self.map_long_form_get_to_new_syntax,
        }

    def _get_graph_item(self, filename: PurePath, calling_func: str) -> RuleGraphGet | None:
        return next(
            (
                item
                for item in self.graphs
                if item["filepath"] == str(filename) and item["function"] == calling_func
            ),
            None,
        )

    def map_get_to_new_syntax(
        self, get: cst.Call, filename: PurePath, calling_func: str
    ) -> Replacement | None:
        """There are 4 forms of Get() syntax.

        This function picks the correct one.
        """

        new_source: cst.Call | None = None
        imports: list[cst.ImportFrom] = []

        if not (graph_item := self._get_graph_item(filename, calling_func)):
            logger.warning(f"Failed to find dependencies for {filename} {calling_func}")
            return None

        get_deps = graph_item["gets"]
        num_args = len(get.args)

        arg_type = None
        if num_args == 2:
            arg_type = type(get.args[1].value)
            if arg_type not in [cst.Call, cst.Dict]:
                logger.warning(f"Failed to migrate: Unknown arg type {get.args[1]}")
                logger.warning(type(get.args[1].value))
                return None

        try:
            logger.error(f"Lookup is {num_args}, {arg_type}")
            lookup = (num_args, arg_type)
            logger.error(f"Lookup is {lookup}")
            func = self.mapping[lookup]
            logger.error(f"Func is {func}")
            new_source, imports = func(get, get_deps)
            # new_source, imports = self.mapping[(num_args, arg_type)](get, get_deps)
        except Exception as e:
            logger.warning(
                f"Failed to migrate Get ({num_args}, {arg_type}) in {filename}:{calling_func} due to: {e}\n"
            )
            logger.debug(
                f"Failed to migrate Get ({num_args}, {arg_type}) in {filename}:{calling_func} due to: {e}",
                exc_info=True,
            )
            return None

        return Replacement(
            filename=filename,
            module=graph_item["module"],
            current_source=get,
            new_source=new_source,
            additional_imports=imports,
        )

    def map_no_args_get_to_new_syntax(
        self, get: cst.Call, deps: list[RuleGraphGetDep]
    ) -> tuple[cst.Call, list[cst.ImportFrom]]:
        """Map the no-args form of Get() to the new syntax.

        The expected mapping is roughly:
        Get(<OutputType>) => the_rule_to_call(**implicitly())

        This form expects that the `get` call has exactly 1 arg (otherwise, a different form would be used)
        """

        logger.debug(dump(get))
        output_type = cst.ensure_type(get.args[0].value, cst.Name).value

        dep = next(
            dep
            for dep in deps
            if dep["output_type"]["name"] == output_type and not dep["input_types"]
        )
        module, new_function = dep["rule_dep"]["module"], dep["rule_dep"]["function"]

        # Look up file associated with module
        # test = _get_call_from_module(module, new_function)
        # logger.error(f"Test is {dump(test)}")

        new_call = cst.Call(
            func=cst.Name(new_function),
            args=[cst.Arg(value=cst.Call(cst.Name("implicitly")), star="**")],
        )
        if called_func := _get_call_from_module(module, new_function):
            new_call = remove_unused_implicitly(new_call, called_func)

        imports = [_make_import_from(module, new_function)]
        return new_call, imports

    def map_long_form_get_to_new_syntax(
        self, get: cst.Call, deps: list[RuleGraphGetDep]
    ) -> tuple[cst.Call, list[cst.ImportFrom]]:
        """Map the long form of Get() to the new syntax.

        The expected mapping is roughly:
        Get(<OutputType>, <InputType>, input) => the_rule_to_call(**implicitly(input))

        This form expects that the `get` call has exactly 3 args (otherwise, a different form would be used)
        """

        logger.debug(dump(get))
        output_type = cst.ensure_type(get.args[0].value, cst.Name).value
        input_type = cst.ensure_type(get.args[1].value, cst.Name).value

        dep = next(
            dep
            for dep in deps
            if dep["output_type"]["name"] == output_type
            and len(dep["input_types"]) == 1
            and dep["input_types"][0]["name"] == input_type
        )
        module, new_function = dep["rule_dep"]["module"], dep["rule_dep"]["function"]

        new_call = cst.Call(
            func=cst.Name(new_function),
            args=[
                cst.Arg(
                    value=cst.Call(
                        func=cst.Name("implicitly"),
                        args=[
                            cst.Arg(
                                value=cst.Dict(
                                    [
                                        cst.DictElement(
                                            key=get.args[2].value, value=cst.Name(input_type)
                                        )
                                    ]
                                )
                            )
                        ],
                    ),
                    star="**",
                )
            ],
        )

        imports = [_make_import_from(module, new_function)]
        return new_call, imports

    def map_short_form_get_to_new_syntax(
        self, get: cst.Call, deps: list[RuleGraphGetDep]
    ) -> tuple[cst.Call, list[cst.ImportFrom]]:
        """Map the short form of Get() to the new syntax.

        The expected mapping is roughly:
        Get(<OutputType>, <InputType>(<constructor args for input>)) => the_rule_to_call(input, **implicitly())

        This form expects that the `get` call has exactly 2 args (otherwise, a different form would be used)
        """

        logger.debug(dump(get))
        output_type = cst.ensure_type(get.args[0].value, cst.Name).value
        input_call = cst.ensure_type(get.args[1].value, cst.Call)
        input_type = cst.ensure_type(input_call.func, cst.Name).value

        dep = next(
            dep
            for dep in deps
            if dep["output_type"]["name"] == output_type
            and len(dep["input_types"]) == 1
            and dep["input_types"][0]["name"] == input_type
        )
        module, new_function = dep["rule_dep"]["module"], dep["rule_dep"]["function"]

        new_call = cst.Call(
            func=cst.Name(new_function),
            args=[
                cst.Arg(value=input_call),
                cst.Arg(value=cst.Call(cst.Name("implicitly")), star="**"),
            ],
        )
        imports = [_make_import_from(module, new_function)]
        return new_call, imports

    def map_dict_form_get_to_new_syntax(
        self, get: cst.Call, deps: list[RuleGraphGetDep]
    ) -> tuple[cst.Call, list[cst.ImportFrom]]:
        """Map the dict form of Get() to the new syntax.

        The expected mapping is roughly:
        Get(<OutputType>, {input1: <Input1Type>, ..inputN: <InputNType>}) => the_rule_to_call(**implicitly(input))

        This form expects that the `get` call has exactly 2 args (otherwise, a different form would be used)
        """

        logger.error(dump(get))
        output_type = cst.ensure_type(get.args[0].value, cst.Name).value
        input_dict = cst.ensure_type(get.args[1].value, cst.Dict)
        input_types = {
            element.value.value
            for element in input_dict.elements
            if isinstance(element.value, cst.Name)
        }

        logger.error(f"After types {input_types}")

        dep = next(
            dep
            for dep in deps
            if dep["output_type"]["name"] == output_type
            and {i["name"] for i in dep["input_types"]} == input_types
        )
        module, new_function = dep["rule_dep"]["module"], dep["rule_dep"]["function"]
        logger.error("After module")

        new_call = cst.Call(
            func=cst.Name(new_function),
            args=[
                cst.Arg(
                    value=cst.Call(func=cst.Name("implicitly"), args=[cst.Arg(input_dict)]),
                    star="**",
                )
            ],
        )
        logger.error("before imports")

        imports = [_make_import_from(module, new_function)]
        return new_call, imports


# ------------------------------------------------------------------------------------------
# Call-by-name visitor
# ------------------------------------------------------------------------------------------


class CallByNameTransformer(m.MatcherDecoratableTransformer):
    def __init__(self, filename: PurePath, syntax_mapper: CallByNameSyntaxMapper) -> None:
        super().__init__()

        self.filename = filename
        self.syntax_mapper = syntax_mapper
        self.calling_function: str = ""
        self.additional_imports: list[cst.ImportFrom] = []

    def visit_FunctionDef(self, node: cst.FunctionDef) -> None:
        self.calling_function = node.name.value

    def leave_FunctionDef(
        self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef
    ) -> cst.FunctionDef:
        self.calling_function = ""
        return updated_node

    @m.leave(m.Call(func=m.Name("Get")))
    def handle_get(self, original_node: cst.Call, updated_node: cst.Call) -> cst.Call:
        replacement = self.syntax_mapper.map_get_to_new_syntax(
            original_node, self.filename, self.calling_function
        )
        if not replacement:
            return updated_node

        # TODO: Should we update_node.with_changes? As we're replacing the entire Call, doesn't matter?
        self.additional_imports.extend(replacement.sanitized_imports())
        return replacement.new_source

    @m.leave(m.Name("MultiGet"))
    def handle_multiget(self, original_node: cst.Name, updated_node: cst.Name) -> cst.Name:
        return updated_node.with_changes(value="concurrently")

    def leave_Module(self, original_node: cst.Module, updated_node: cst.Module) -> cst.Module:
        if not self.additional_imports:
            return updated_node

        rules_import_index = 1
        for i, statement in enumerate(updated_node.body):
            if m.matches(
                statement,
                matcher=m.SimpleStatementLine(
                    body=[m.ImportFrom(module=_make_import_from_1("pants.engine.rules"))]
                ),
            ):
                logger.error(i)
                rules_import_index = i + 1
                break

        self.additional_imports.append(_make_import_from("pants.engine.rules", "implicitly"))
        additional_import_statements = [
            cst.SimpleStatementLine(body=[i]) for i in self.additional_imports
        ]
        additional_import_statements = [
            v1
            for i, v1 in enumerate(additional_import_statements)
            if not any(v1.deep_equals(v2) for v2 in additional_import_statements[:i])
        ]

        return updated_node.with_changes(
            body=[
                *updated_node.body[:rules_import_index],
                *additional_import_statements,
                *updated_node.body[rules_import_index:],
            ]
        )


# ------------------------------------------------------------------------------------------
# cst utilities
# ------------------------------------------------------------------------------------------


def _make_import_from(module: str, func: str) -> cst.ImportFrom:
    """Manually generating ImportFrom using Attributes is tricky, parse a string instead."""
    return cst.ImportFrom(
        module=_make_importfrom_attr(module), names=[cst.ImportAlias(cst.Name(func))]
    )
    # cst.ImportFrom(module=_make_import_from_1(module), names=[])
    # statement = cst.parse_statement(f"from {module} import {func}")
    # assert isinstance(statement.body, Sequence)
    # return cst.ensure_type(statement.body[0], cst.ImportFrom)


def _make_importfrom_attr(module: str) -> cst.Attribute | cst.Name:
    parts = module.split(".")
    if len(parts) == 1:
        return cst.Name(parts[0])
    # Otherwise, it is an Attribute
    partial_module = ".".join(parts[:-1])
    return cst.Attribute(value=_make_importfrom_attr(partial_module), attr=cst.Name(parts[-1]))


def _make_import_from_1(module: str) -> Union[m.Attribute, m.Name]:
    """Build matcher for a module given sequence of import parts."""
    # If only one element, it is just a Name
    parts = module.split(".")
    if len(parts) == 1:
        return m.Name(parts[0])
    # Otherwise, it is an Attribute
    partial_module = ".".join(parts[:-1])
    return m.Attribute(value=_make_import_from_1(partial_module), attr=m.Name(parts[-1]))

    # *values, attr = parts
    # value = _make_import_from_1(values)
    # return m.Attribute(value=value, attr=m.Name(attr))


def remove_unused_implicitly(call: cst.Call, called_func: cst.FunctionDef) -> cst.Call:
    """The CallByNameSyntaxMapper aggressively adds `implicitly` for safety. This function removes
    unnecessary ones.

    The following cases are handled:
    - The called function takes no arguments
    - TODO: The called function takes the same number of arguments that are passed to it
    - TODO: Check the types of the passed in parameters, if they don't match, they need to be implicitly passed
    """
    called_params = len(called_func.params.params)
    if called_params == 0:
        return call.with_changes(args=[])


def _get_call_from_module(module: str, func: str) -> cst.FunctionDef | None:
    """Open the associated file, and parse the func into a Call.

    The purpose of this is to determine whether we need `implicitly` or not.
    so perform this call as lazily as possible - rather than adding it to
    the migration.
    """
    if not (spec := importlib.util.find_spec(module)):
        logger.warning(f"Failed to find module {module}")
        return None

    assert spec.origin is not None

    with open(spec.origin) as f:
        source_code = f.read()
        tree = cst.parse_module(source_code)
        # m.matches(tree.body[0], matcher=m.FunctionDef())
        results = m.findall(tree, matcher=m.FunctionDef(m.Name(func)))
        logger.error(f"Results are {results}")
        return cst.ensure_type(results[0], cst.FunctionDef) if results else None
