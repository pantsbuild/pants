# Copyright 2021 Pants project contributors (see CONTRIBUTORS.md).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

import hashlib
import json
from dataclasses import dataclass

from pants.backend.python.util_rules.interpreter_constraints import InterpreterConstraints
from pants.util.ordered_set import FrozenOrderedSet

BEGIN_LOCKFILE_HEADER = b"# --- BEGIN PANTS LOCKFILE METADATA: DO NOT EDIT OR REMOVE ---"
END_LOCKFILE_HEADER = b"# --- END PANTS LOCKFILE METADATA ---"


@dataclass
class LockfileMetadata:
    invalidation_digest: str | None


def calculate_invalidation_digest(
    requirements: FrozenOrderedSet[str], interpreter_constraints: InterpreterConstraints
) -> str:
    """Returns an invalidation digest for the given requirements and interpreter constraints."""
    m = hashlib.sha256()
    pres = {
        "requirements": list(requirements),
        "interpreter_constraints": [str(i) for i in interpreter_constraints],
    }
    m.update(json.dumps(pres).encode("utf-8"))
    return m.hexdigest()


def lockfile_content_with_header(
    regenerate_command: str, invalidation_digest: str, content: bytes
) -> bytes:
    """Returns a version of the lockfile with Pants metadata prepended."""
    regenerate_command = (
        f"# This lockfile was autogenerated by Pants. To regenerate, run:\n#\n"
        f"#    {regenerate_command}"
    )
    return b"%b\n#\n%b\n\n%b" % (
        regenerate_command.encode("utf-8"),
        lockfile_metadata_header(invalidation_digest),
        content,
    )


def lockfile_metadata_header(invalidation_digest: str) -> bytes:
    """Produces a metadata bytes object for including at the top of a lockfile.

    Currently, this only consists of an invalidation digest for the file, which is used when Pants
    consumes the lockfile during builds.
    """
    return (
        b"""
%(BEGIN_LOCKFILE_HEADER)b
# invalidation digest: %(invalidation_digest)s
%(END_LOCKFILE_HEADER)b
    """
        % {
            b"BEGIN_LOCKFILE_HEADER": BEGIN_LOCKFILE_HEADER,
            b"invalidation_digest": invalidation_digest.encode("ascii"),
            b"END_LOCKFILE_HEADER": END_LOCKFILE_HEADER,
        }
    ).strip()


def read_lockfile_metadata(contents: bytes) -> LockfileMetadata:
    """Reads through `contents`, and returns the contents of the lockfile metadata block as a
    `LockfileMetadata` object."""

    metadata = {}

    in_metadata_block = False
    for line in contents.splitlines():
        line = line.strip()
        if line == BEGIN_LOCKFILE_HEADER:
            in_metadata_block = True
        elif line == END_LOCKFILE_HEADER:
            break
        elif in_metadata_block:
            key, value = (i.strip().decode("ascii") for i in line[1:].split(b":"))
            metadata[key] = value

    return LockfileMetadata(invalidation_digest=metadata.get("invalidation digest"))
