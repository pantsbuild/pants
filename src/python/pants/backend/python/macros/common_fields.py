# Copyright 2022 Pants project contributors (see CONTRIBUTORS.md).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

from typing import Any, ClassVar, Dict, Iterable, Tuple

from packaging.utils import canonicalize_name as canonicalize_project_name

from pants.backend.python.target_types import normalize_module_mapping
from pants.engine.addresses import Address
from pants.engine.target import DictStringToStringSequenceField, OverridesField
from pants.util.frozendict import FrozenDict


class ModuleMappingField(DictStringToStringSequenceField):
    alias = "module_mapping"
    help = (
        "A mapping of requirement names to a list of the modules they provide.\n\n"
        'For example, `{"ansicolors": ["colors"]}`.\n\n'
        "Any unspecified requirements will use the requirement name as the default module, "
        'e.g. "Django" will default to `["django"]`.\n\n'
        "This is used to infer dependencies."
    )
    value: FrozenDict[str, tuple[str, ...]]
    default: ClassVar[FrozenDict[str, tuple[str, ...]]] = FrozenDict()

    @classmethod
    def compute_value(  # type: ignore[override]
        cls, raw_value: Dict[str, Iterable[str]], address: Address
    ) -> FrozenDict[str, Tuple[str, ...]]:
        value_or_default = super().compute_value(raw_value, address)
        return normalize_module_mapping(value_or_default)


class TypeStubsModuleMappingField(DictStringToStringSequenceField):
    alias = "type_stubs_module_mapping"
    help = (
        "A mapping of type-stub requirement names to a list of the modules they provide.\n\n"
        'For example, `{"types-requests": ["requests"]}`.\n\n'
        "If the requirement is not specified _and_ it starts with `types-` or `stubs-`, or ends "
        "with `-types` or `-stubs`, the requirement will be treated as a type stub for the "
        'corresponding module, e.g. "types-request" has the module "requests". Otherwise, '
        "the requirement is treated like a normal dependency (see the field "
        f"{ModuleMappingField.alias}).\n\n"
        "This is used to infer dependencies for type stubs."
    )
    value: FrozenDict[str, tuple[str, ...]]
    default: ClassVar[FrozenDict[str, tuple[str, ...]]] = FrozenDict()

    @classmethod
    def compute_value(  # type: ignore[override]
        cls, raw_value: Dict[str, Iterable[str]], address: Address
    ) -> FrozenDict[str, Tuple[str, ...]]:
        value_or_default = super().compute_value(raw_value, address)
        return normalize_module_mapping(value_or_default)


class RequirementsOverrideField(OverridesField):
    help = (
        "Override the field values for generated `python_requirement` targets.\n\n"
        "Expects a dictionary of requirements to a dictionary for the "
        "overrides. You may either use a string for a single requirement, "
        "or a string tuple for multiple requirements. Each override is a dictionary of "
        "field names to the overridden value.\n\n"
        "For example:\n\n"
        "```\n"
        "overrides={\n"
        '  "django": {"dependencies": ["#setuptools"]]},\n'
        '  "ansicolors": {"description": "pretty colors"]},\n'
        '  ("ansicolors, "django"): {"tags": ["overridden"]},\n'
        "}\n"
        "```\n\n"
        "Every overridden requirement is validated to be generated by this target.\n\n"
        "You can specify the same requirement in multiple keys, so long as you don't "
        "override the same field more than one time for the requirement."
    )

    def flatten_and_normalize(self) -> dict[str, dict[str, Any]]:
        return {canonicalize_project_name(req): v for req, v in super().flatten().items()}
