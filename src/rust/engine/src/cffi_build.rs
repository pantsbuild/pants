extern crate gcc;

/*

N.B. This build script is invoked by `cargo` by way of this configuration
in our Cargo.toml:

    [project]
    ...
    build = "src/cffi_build.rs"

Within, we use the `gcc` crate to compile the CFFI C sources (`native_engine.c`)
generated by `bootstrap.sh` into a (private) static lib (`libnative_engine_ffi.a`),
which then gets linked into the final `cargo build` product (the native engine binary).
This process mixes the Python module initialization function and other symbols into the
native engine binary, allowing us to address it both as an importable python module
(`from _native_engine import X`) as well as a C library (`ffi.dlopen(native_engine.so)`).

*/

use std::fs;
use std::io::{Read, Result};
use std::path::{Path, PathBuf};

fn main() {
  let mut config = gcc::Config::new();

  // N.B. The filename of this source code - at generation time - must line up 1:1 with the
  // python import name, as python keys the initialization function name off of the import name.
  let path = PathBuf::from("src/cffi/native_engine.c");

  config.file(path.to_str().unwrap());
  for flag in make_flags(&path).unwrap() {
    config.flag(flag.as_str());
  }

  config.compile("libnative_engine_ffi.a");
}

fn make_flags(c_file: &Path) -> Result<Vec<String>> {
  let mut path = PathBuf::from(c_file);
  path.set_extension("cflags");

  let mut contents = String::new();
  fs::File::open(path)?.read_to_string(&mut contents)?;
  // It would be a shame if someone were to include a space in an actual quoted value.
  // If they did that, I guess we'd need to implement shell tokenization or something.
  return Ok(contents.trim().split(' ').map(str::to_owned).collect());
}
