extern crate cc;

/*

N.B. This build script is invoked by `cargo` by way of this configuration
in our Cargo.toml:

    [project]
    ...
    build = "src/cffi_build.rs"

Within, we use the `gcc` crate to compile the CFFI C sources (`native_engine.c`)
generated by `bootstrap.sh` into a (private) static lib (`libnative_engine_ffi.a`),
which then gets linked into the final `cargo build` product (the native engine binary).
This process mixes the Python module initialization function and other symbols into the
native engine binary, allowing us to address it both as an importable python module
(`from _native_engine import X`) as well as a C library (`ffi.dlopen(native_engine.so)`).

*/

use std::fs;
use std::io::{Read, Result};
use std::path::{Path, PathBuf};

fn main() {
  let mut config = cc::Build::new();

  // Don't implicitly set -Wall -Wextra because cffi generates code with warnings.
  // TODO: Consider removing this if/when https://github.com/alexcrichton/cc-rs/pull/248 lands.
  config.warnings(false);

  // N.B. The filename of this source code - at generation time - must line up 1:1 with the
  // python import name, as python keys the initialization function name off of the import name.
  let cffi_dir = Path::new("src/cffi");
  let c_path = mark_for_change_detection(cffi_dir.join("native_engine.c"));
  let env_script_path = mark_for_change_detection(cffi_dir.join("native_engine.cflags"));

  config.file(c_path.to_str().unwrap());
  for flag in make_flags(&env_script_path).unwrap() {
    config.flag(flag.as_str());
  }

  config.compile("libnative_engine_ffi.a");
}

fn mark_for_change_detection(path: PathBuf) -> PathBuf {
  // Restrict re-compilation check to just our input files.
  // See: http://doc.crates.io/build-script.html#outputs-of-the-build-script
  println!("cargo:rerun-if-changed={}", path.to_str().unwrap());
  path
}

fn make_flags(env_script_path: &Path) -> Result<Vec<String>> {
  let mut contents = String::new();
  fs::File::open(env_script_path)?.read_to_string(
    &mut contents,
  )?;
  // It would be a shame if someone were to include a space in an actual quoted value.
  // If they did that, I guess we'd need to implement shell tokenization or something.
  return Ok(
    contents
      .trim()
      .split_whitespace()
      .map(str::to_owned)
      .collect(),
  );
}
