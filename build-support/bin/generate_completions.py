# Copyright 2022 Pants project contributors (see CONTRIBUTORS.md).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

import json
import subprocess

BASH_COMPLETION_TEMPLATE = """
# DO NOT EDIT.
# This script is autogenerated by build-support/bin/generate_autocomplete.py

function pants_completions()
{{
    readonly PANTS_GOALS="\\
        {goals}"

    {goal_options}

    local current_word previous_word previous_goal

    current_word=${{COMP_WORDS[COMP_CWORD]}}
    previous_word=${{COMP_WORDS[COMP_CWORD-1]}}
    previous_goal=$(get_previous_goal)

    case "$previous_goal" in
    {goal_cases}
    esac

    # Show goals, unless the tab completion has a hyphen - then show global/goal options instead
    if [[ $current_word == -* ]]; then
        COMPREPLY=( $( compgen -W "$complete_options" -- $current_word ))
    else
        COMPREPLY=( $( compgen -W "$PANTS_GOALS" -- $current_word ))
    fi
    return 0
}}

# Get the most recent goal in the command arguments, so options can be correctly applied
# This function will ignore hyphenated options when looking for the goal
# If this is empty, we're at the top-level Pants command
function get_previous_goal()
{{
    local previous_goal i current_word
    previous_goal=
    for (( i=$COMP_CWORD; i > 0; --i )); do
        current_word=${{COMP_WORDS[i]}}
        if [[ $current_word != -* ]]; then
            previous_goal=$current_word
            break
        fi
    done
    echo $previous_goal
}}

# TODO: Need to create a separate .zsh script instead of this
autoload -U +X bashcompinit && bashcompinit
autoload -Uz compinit && compinit

complete -o default -o bashdefault -F pants_completions pants
"""

GOAL_OPTIONS_TEMPLATE = """
    readonly PANTS_{name}_OPTIONS="\\
        {options}"
"""

GOAL_CASE_TEMPLATE = """
    {goal})
        complete_options="$PANTS_{bash_name}_OPTIONS"
        ;;
"""


def _run_pants_help():
    process = subprocess.run(["./pants", "help-all"], capture_output=True, check=True)
    process.check_returncode()
    return json.loads(process.stdout)


def _parse_help_for_goal_names(help: dict) -> list[str]:
    goals_dict = help["name_to_goal_info"]
    return sorted(set(goals_dict.keys()))


def _parse_help_for_options(help: dict, scope: str) -> tuple[list[str], list[str]]:
    """scope represents the goal or subsystem of interest Returns a tuple containing the scoped
    options, followed by unscoped."""
    scoped_help = help["scope_to_help_info"][scope]

    scoped_options = []
    unscoped_options = []
    for option in scoped_help["basic"] + scoped_help["advanced"]:
        scoped_options.extend(option["scoped_cmd_line_args"])
        unscoped_options.extend(option["unscoped_cmd_line_args"])
    return (
        sorted(scoped_options),
        sorted(unscoped_options),
    )


def _bashify_goal(name: str) -> str:
    # Replace hyphens with underscores for variable names
    # Use upper-case goal names
    return name.replace("-", "_").upper()


# TODO: Blah. I don't like this function at all...
# TODO: "goal" options is the wrong name, as we include some subsystems and globals
def _hydrate_bash_template(goal_options: dict[str, list[str]]) -> str:
    # Handle the top-level PANTS_GOALS variable
    goals_str = "\\\n        ".join(goal_options.keys())

    # Handle creating variables of the form PANTS_{GOAL}_OPTIONS
    goal_options_str = ""
    for name, options in goal_options.items():
        goal_options_str += GOAL_OPTIONS_TEMPLATE.format(
            name=_bashify_goal(name), options="\\\n        ".join(options)
        )

    # Handle enumerating the completion case statements and variable names
    # TODO: Fix the naming here, I ended up confusing myself all for that single * (probably just create a dict somewhere to reference)
    goal_cases_str = ""
    for goal_name in goal_options.keys():
        name = goal_name
        if goal_name == "global":
            name = "*"

        goal_cases_str += GOAL_CASE_TEMPLATE.format(goal=name, bash_name=_bashify_goal(goal_name))

    return BASH_COMPLETION_TEMPLATE.format(
        goals=goals_str, goal_options=goal_options_str, goal_cases=goal_cases_str
    )


def main() -> None:
    help_results = _run_pants_help()
    scoped_options: list[str] = []

    goal_names = _parse_help_for_goal_names(help_results)
    goal_options: dict[str, list[str]] = {}
    for name in goal_names:
        scoped_goal_options, unscoped_goal_options = _parse_help_for_options(help_results, name)
        goal_options[name] = unscoped_goal_options
        scoped_options.extend(scoped_goal_options)

    # These are selected subsystems where we want auto-completion
    subsystem_names = ["changed"]
    for name in subsystem_names:
        scoped_subsystem_options, _ = _parse_help_for_options(help_results, name)
        scoped_options.extend(scoped_subsystem_options)

    # Special case for global options, the scope name is ""
    scoped_global_options, _ = _parse_help_for_options(help_results, "")
    scoped_options.extend(scoped_global_options)

    global_options = sorted(scoped_options)
    goal_options["global"] = global_options

    print(_hydrate_bash_template(goal_options))


if __name__ == "__main__":
    main()
