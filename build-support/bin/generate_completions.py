# Copyright 2022 Pants project contributors (see CONTRIBUTORS.md).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

from __future__ import annotations

import json
import subprocess

BASH_COMPLETION_TEMPLATE = """
# DO NOT EDIT.
# This script is autogenerated by build-support/bin/generate_autocomplete.py

readonly PANTS_GOALS="\\
    {goals}"

{goal_options}

function pants_completions()
{{
    local current_word previous_word previous_goal

    current_word=${{COMP_WORDS[COMP_CWORD]}}
    previous_word=${{COMP_WORDS[COMP_CWORD-1]}}
    previous_goal=$(get_previous_goal)

    case "$previous_goal" in
    {goal_cases}
    esac

    # Show goals, unless the tab completion has a hyphen - then show global/goal options instead
    if [[ $current_word == -* ]]; then
        COMPREPLY=( $( compgen -W "$complete_options" -- $current_word ))
    else
        COMPREPLY=( $( compgen -W "$PANTS_GOALS" -- $current_word ))
    fi
    return 0
}}

# Get the most recent goal in the command arguments, so options can be correctly applied
# This function will ignore hyphenated options when looking for the goal
# If this is empty, we're at the top-level Pants command
function get_previous_goal()
{{
    local previous_goal i current_word
    previous_goal=
    for (( i=$COMP_CWORD; i > 0; --i )); do
        current_word=${{COMP_WORDS[i]}}
        if [[ $current_word != -* ]]; then
            previous_goal=$current_word
            break
        fi
    done
    echo $previous_goal
}}

# TODO: Need to create a separate .zsh script instead of this
autoload -U +X bashcompinit && bashcompinit
autoload -Uz compinit && compinit

complete -F pants_completions pants
"""

GOAL_OPTIONS_TEMPLATE = """
readonly PANTS_{name}_OPTIONS="\\
    {options}"
"""

GOAL_CASE_TEMPLATE = """
    {goal})
        complete_options="$PANTS_{bash_name}_OPTIONS"
        ;;
"""


def _run_pants_help():
    process = subprocess.run(["./pants", "help-all"], capture_output=True, check=True)
    process.check_returncode()
    return json.loads(process.stdout)


def _parse_help_for_goal_names(help: dict) -> list[str]:
    goals_dict = help["name_to_goal_info"]
    return sorted(set(goals_dict.keys()))


def _parse_help_for_goal_options(help: dict, goal_name: str) -> list[str]:
    goal_help = help["scope_to_help_info"][goal_name]
    # TODO: Scoped or unscoped? Scoped should probably be available globally as well
    goal_options = []
    for option in goal_help["basic"] + goal_help["advanced"]:
        goal_options.extend(option["unscoped_cmd_line_args"])
    return sorted(goal_options)


def _bashify_goal(name: str) -> str:
    # Replace hyphens with underscores for variable names
    # Use upper-case goal names
    return name.replace("-", "_").upper()


def _hydrate_bash_template(goal_options: dict[str, list[str]]) -> str:
    # Handle the top-level PANTS_GOALS variable
    goals_str = "\\\n   ".join(goal_options.keys())

    # Handle creating variables of the form PANTS_{GOAL}_OPTIONS
    goal_options_str = ""
    for name, options in goal_options.items():
        print(options)
        goal_options_str += GOAL_OPTIONS_TEMPLATE.format(
            name=_bashify_goal(name), options="\\\n   ".join(options)
        )

    # Handle enumerating the completion case statements
    goal_cases_str = ""
    for name in goal_options.keys():
        if name == "global":
            name = "*"

        goal_cases_str += GOAL_CASE_TEMPLATE.format(goal=name, bash_name=_bashify_goal(name))

    return BASH_COMPLETION_TEMPLATE.format(
        goals=goals_str, goal_options=goal_options_str, goal_cases=goal_cases_str
    )


def main() -> None:
    help_results = _run_pants_help()
    goal_names = _parse_help_for_goal_names(help_results)

    goal_options = {name: _parse_help_for_goal_options(help_results, name) for name in goal_names}

    # Special case for global options, the goal name is ""
    global_options = _parse_help_for_goal_options(help_results, "")
    goal_options["global"] = global_options

    print(_hydrate_bash_template(goal_options))


if __name__ == "__main__":
    main()
